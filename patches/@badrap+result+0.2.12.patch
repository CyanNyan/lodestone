diff --git a/node_modules/@badrap/result/dist/index.d.ts b/node_modules/@badrap/result/dist/index.d.ts
index c7da559..e3c8ae9 100644
--- a/node_modules/@badrap/result/dist/index.d.ts
+++ b/node_modules/@badrap/result/dist/index.d.ts
@@ -1,36 +1,36 @@
-declare abstract class _Result<T, E extends Error> {
-    protected abstract _chain<X, U extends Error>(ok: (value: T) => Result<X, U>, err: (error: E) => Result<X, U>): Result<X, U>;
+declare abstract class _Result<T, E > {
+    protected abstract _chain<X, U >(ok: (value: T) => Result<X, U>, err: (error: E) => Result<X, U>): Result<X, U>;
     unwrap(): T;
     unwrap<U>(ok: (value: T) => U): U;
     unwrap<U, V>(ok: (value: T) => U, err: (error: E) => V): U | V;
     unwrap<U>(ok: (value: T) => U, err: (error: E) => U): U;
     map<U>(ok: (value: T) => U): Result<U, E>;
-    map<U, F extends Error>(ok: (value: T) => U, err: (error: E) => F): Result<U, F>;
+    map<U, F >(ok: (value: T) => U, err: (error: E) => F): Result<U, F>;
     chain<X>(ok: (value: T) => Result<X, E>): Result<X, E>;
     chain<X>(ok: (value: T) => Result<X, E>, err: (error: E) => Result<X, E>): Result<X, E>;
-    chain<X, U extends Error>(ok: (value: T) => Result<X, U>, err: (error: E) => Result<X, U>): Result<X, U>;
+    chain<X, U >(ok: (value: T) => Result<X, U>, err: (error: E) => Result<X, U>): Result<X, U>;
 }
-declare class _Ok<T, E extends Error> extends _Result<T, E> {
+declare class _Ok<T, E > extends _Result<T, E> {
     readonly value: T;
     readonly isOk = true;
     readonly isErr = false;
     constructor(value: T);
-    protected _chain<X, U extends Error>(ok: (value: T) => Result<X, U>, _err: (error: E) => Result<X, U>): Result<X, U>;
+    protected _chain<X, U >(ok: (value: T) => Result<X, U>, _err: (error: E) => Result<X, U>): Result<X, U>;
 }
-declare class _Err<T, E extends Error> extends _Result<T, E> {
+declare class _Err<T, E > extends _Result<T, E> {
     readonly error: E;
     readonly isOk = false;
     readonly isErr = true;
     constructor(error: E);
-    protected _chain<X, U extends Error>(_ok: (value: T) => Result<X, U>, err: (error: E) => Result<X, U>): Result<X, U>;
+    protected _chain<X, U >(_ok: (value: T) => Result<X, U>, err: (error: E) => Result<X, U>): Result<X, U>;
 }
 export declare namespace Result {
-    export interface Ok<T, E extends Error> extends _Ok<T, E> {
+    export interface Ok<T, E > extends _Ok<T, E> {
     }
-    export interface Err<T, E extends Error> extends _Err<T, E> {
+    export interface Err<T, E > extends _Err<T, E> {
     }
-    export function ok<T, E extends Error>(value: T): Result<T, E>;
-    export function err<E extends Error, T = never>(error?: E): Result<T, E>;
+    export function ok<T, E >(value: T): Result<T, E>;
+    export function err<E , T = never>(error?: E): Result<T, E>;
     type U = Result<unknown>;
     export function all<R0 extends U, R1 extends U, R2 extends U, R3 extends U, R4 extends U, R5 extends U, R6 extends U, R7 extends U, R8 extends U, R9 extends U, R10 extends U, R11 extends U, R12 extends U, R13 extends U, R14 extends U, R15 extends U>(obj: [R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15]): Result<[
         OkType<R0>,
@@ -198,7 +198,7 @@ export declare namespace Result {
     }[keyof T]>;
     export {};
 }
-export declare type Result<T, E extends Error = Error> = Result.Ok<T, E> | Result.Err<T, E>;
+export declare type Result<T, E  = Error> = Result.Ok<T, E> | Result.Err<T, E>;
 declare type OkType<R extends Result<unknown>> = R extends Result<infer O> ? O : never;
 declare type ErrType<R extends Result<unknown>> = R extends Result<unknown, infer E> ? E : never;
 export {};
